## 银行家算法



**银行家算法中的数据结构**
　　为了实现银行家算法，在系统中必须设置这样四个数据结构，分别用来描述系统中可利用的资源、所有进程对资源的最大需求、系统中的资源分配，以及所有进程还需要多少资源的情况。
　　(1) 可利用资源向量 Available。这是一个含有 m 个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果 Available[j] = K，则表示系统中现有Rj类资源K个。
　　(2) 最大需求矩阵Max。这是一个n x m的矩阵，它定义了系统中n个进程中的每个进程对m类资源的**最大需求**。如果Max[i,j] = K，则表示进程i需要Rj 类资源的最大数目为K。
　　(3) 分配矩阵 Allocation。这也是一个n x m的矩阵，它定义了系统中每一类资源当前**已分配**给每一进程的资源数。如果 Allocation[i,jl = K，则表示进程i当前己分得Rj类资源的数目为K。
　　(4) 需求矩阵Need.这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j] = K，则表示进程i还需要Rj类资源K个方能完成其任务。
上述三个矩阵间存在下述关系:
　　　　　　　　　　　　　　Need[i,j] = Max[i,j] - allocation[i, j]

**银行家算法详述：**

某个进程申请资源，进行可分配资源的判断，尝试修改后进行安全性算法判断

设 Request；是进程Pi的请求向量，如果 Requesti[j] = K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检査:
　　(1) 如果 Requesti[j] ≤ Need[i,j]便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。
　　(2) 如果 Requesti[j] ≤ Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。
　　(3) 系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值
　　　　Available[j] = Available[j] - Requesti[j];
　　　　Allocation[i,j] = Allocation[i,j] + Requesti[j];
　　　　Need[i,j] = Need[i,j] - Requesti[j];
　　(4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。
　　
**安全性算法:**

某一个时刻中，单线程模式下（多线程模式需要多实现一些其他的判断），进程按一定顺序调度并释放资源，资源能否足够下一个进程进行调用，最后所有进程是否能保证不出现死锁情况，避免死锁。

系统所执行的安全性算法可描述如下:
　　(1) 设置两个向量:

​				①工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work = Available；

​				② Finish:它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做 Finish[i] = false；当有足够资源分配给进程时，再令Finish[i] = true。
　　(2) 从进程集合中找到一个能满足下述条件的进程
　　　　① Finish[i] = false;
　　　　② Need[i,j] ≤ Work[j];
若找到，执行步骤(3)，否则，执行步骤(4)。
　　(3)当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行:
　　　　Work[j] = Work[j] + Allocation[i,j];
　　　　Finish[i] = true;
　　　　go to step 2;(goto语句不推荐使用 _ )
　　(4)如果所有进程的 Finish[i] =true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。



**银行家算法实例**
    假定系统中有五个进程{P0，P1，P2，P3，P4}和三类资源{A，B，C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图3-15所示。 （先忽略P0、P1第二行的括号）

| 进程\资源情况 | Max             | Allocation    | Need          | Available   |
| ------------- | --------------- | ------------- | ------------- | ----------- |
|               | A    B    C     | A    B    C   | A    B    C   | A    B    C |
| P0            | 7    5    3     | 0    1    0   | 7    4    3   | 3    3    2 |
|               |                 |               | (2    3    0) |             |
| P1            | 3    2    2     | 2    0    0   | 1    2    2   |             |
|               | （3    0    2） | (0    2    0) |               |             |
| P2            | 9    0    2     | 3    0    2   | 6    0    0   |             |
| P3            | 2    2    2     | 2    1    1   | 0    1    1   |             |
| P4            | 4    3    3     | 0    0    2   | 4    3    1   |             |

​           																									 图3-15 T0时刻的资源分配表



(1)T0时刻的安全性：利用安全性算法对 T0时刻的资源分配情况进行分析(见图3-16所示)可知，在 T0时刻存在着一个安全序列{P1，P3，P4，P2，P0}，故系统是安全的。

| 进程\资源情况 | Work         | Need        | Allocation  | Work+Allocation | finish      |
| ------------- | ------------ | ----------- | ----------- | --------------- | ----------- |
|               | A    B    C  | A    B    C | A    B    C | A    B    C     | A    B    C |
| P1            | 3    3    2  | 1    2    2 | 2    0    0 | 5    3    2     | true        |
| P3            | 5    3    2  | 0    1    1 | 2    1    1 | 7    4    3     | true        |
| P4            | 7    4    3  | 4    3    1 | 0    0    2 | 7    4    5     | true        |
| P2            | 7    4    5  | 6    0    0 | 3    0    2 | 10    4    7    | true        |
| P0            | 10    4    7 | 7    4    3 | 0    1    0 | 10    5    7    | true        |

​          																							  图3-16 T0时刻的安全序列



(2) P1请求资源：P1发出请求向量 Request`1`(1，0，2)，系统按银行家算法进行检查：① Request`1`(1，0，2)≤Need`1`(1，2，2) ;
② Request`1`(1，0，2)≤Available`1`(3，3，2);
③ 系统先假定可为 P`1`分配资源，并修改 Available，Allocation`1`和 Need`1`向量，由此形成的资源变化情况如图 3-15 中的圆括号所示；
④ 再利用安全性算法检查此时系统是否安全，如图3-17所示。

| 进程\资源情况 | Work        | Need        | Allocation  | Work+Allocation | finish      |
| ------------- | ----------- | ----------- | ----------- | --------------- | ----------- |
|               | A    B    C | A    B    C | A    B    C | A    B    C     | A    B    C |
| P1            | 2    3    0 | 0    2    0 | 3    0    2 | 5    3    2     | true        |
| P3            | 5    3    2 | 0    1    1 | 2    1    1 | 7    4    3     | true        |
| P4            | 7    4    3 | 4    3    1 | 0    0    2 | 7    4    5     | true        |
| P2            | 7    4    5 | 7    4    3 | 0    1    0 | 7    5    5     | true        |
| P0            | 7    5    5 | 6    0    0 | 3    0    2 | 10    5    7    | true        |

​            																						图3-17 P1申请资源时的安全性检查
​    由所进行的安全性检查得知，可以找到一个安全序列{P1，P3，P4，P2，P0}。因此，系统是安全的，可以立即将P1申请的资源分配给它。



(3) P`4`请求资源：P`4`发出请求向量 Request`4`(3，3，0)，系统按银行家算法进行检查：
① Request`4`(3，3，0)≤Need`4`(4，3，1)；
② Request`4`(3，3，0)≤Available(2，3，0)，让 P4等待。
(4) P0请求资源：P`0`发出请求向量 Requst`0`(0，2，0)，系统按银行家算法进行检查： ① Request`0`(0，2，0)≤Need`0`(7，4，3)；
② Request`0`(0，2，0)≤Available(2，3，0)；
③ 系统暂时先假定可为 P`0`分配资源，并修改有关数据，如图 3-18所示。

| 进程\资源情况 | Allocation  | Need        | Available   |
| ------------- | ----------- | ----------- | ----------- |
|               | A    B    C | A    B    C | A    B    C |
| P0            | 0    3    0 | 7    2    3 | 2    1    0 |
| P1            | 3    0    2 | 0    2    0 |             |
| P2            | 3    0    2 | 6    0    0 |             |
| P3            | 2    1    1 | 0    1    1 |             |
| P4            | 0    0    2 | 4    3    1 |             |

​            																								图3-18为 P0分配资源后的有关资源数据



(5) 进行安全性检查：可用资源 Available(2，1，0)已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。

​    在银行家算法的例子中，如果P0发出的请求向量由Request（0,2,0）改为Request（0,1,0），请问系统可否将资源分配给它？
P0请求资源：P`0`发出请求向量Request0（0,1,0），系统按银行家算法进行检查：
① Request`0`（0,1,0）≤Need`0`（7,4,3）；
② Request`0`（0,1,0）≤Available（2,3,0）；
③ 系统先假定可为P0分配资源，并修改Available，Allocation和Need向量，由此形成的资源变化情况如下图所示：

| 进程\资源情况 | Work         | Need        | Allocation  | Work+Allocation | finish      |
| ------------- | ------------ | ----------- | ----------- | --------------- | ----------- |
|               | A    B    C  | A    B    C | A    B    C | A    B    C     | A    B    C |
| P1            | 2    2    0  | 0    2    0 | 3    0    2 | 5    2    2     | true        |
| P3            | 5    2    2  | 0    1    1 | 2    1    1 | 7    3    3     | true        |
| P4            | 7    3    3  | 4    3    1 | 0    0    2 | 7    3    5     | true        |
| P2            | 7    3    5  | 6    0    0 | 3    0    2 | 10    3    7    | true        |
| P0            | 10    3    7 | 7    3    3 | 0    2    0 | 10    5    7    | true        |