### NoSuchMethodException

1. 存在同包同名的class文件，方法不一致，**由于jvm的类加载机制，可能会加载另一个不是我们想要的class**。所以在运行的时候报错java.lang.NoSuchMethodException.
2. 在 Filter中注入 对象时失败（用@AllConstructor这中filter对象的init方法注入的直接erorr，用@autowried空时可以先跳过），注入的service始终为null

原理：spring实例化java bean的顺序问题，filter的构造器实例化比@Service 的实例化快（未查到根本解决方式），写公共服务时filter等组件的

eg: 

```java
public class WeiXinFilter implements Filter{
    
    @Autowired
    private UsersService usersService;

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest)request;
        HttpServletResponse resp = (HttpServletResponse)response;
　　　　 Users users = this.usersService.queryByOpenid(openid);
}
```

解决方式：

1. 在过滤器的dofliter直接从上下文获取

```java
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest)request;
        HttpServletResponse resp = (HttpServletResponse)response;
        ServletContext sc = req.getSession().getServletContext();
        XmlWebApplicationContext cxt = (XmlWebApplicationContext)WebApplicationContextUtils.getWebApplicationContext(sc);
        
        if(cxt != null && cxt.getBean("usersService") != null && usersService == null)
            usersService = (UsersService) cxt.getBean("usersService");
        
        Users users = this.usersService.queryByOpenid(openid);
}
```

2. 过滤器init初始化时,此时@Service 的bean已经实例化

``` java 
public class WeiXinFilter implements Filter{
    
    private UsersService usersService;
    
    public void init(FilterConfig fConfig) throws ServletException {
        ServletContext sc = fConfig.getServletContext(); 
        XmlWebApplicationContext cxt = (XmlWebApplicationContext)WebApplicationContextUtils.getWebApplicationContext(sc);
        
        if(cxt != null && cxt.getBean("usersService") != null && usersService == null)
            usersService = (UsersService) cxt.getBean("usersService");        
    }
}
```

> **如何获取 ServletContext**：
>
> 1）在javax.servlet.Filter中直接获取 
> ServletContext context = config.getServletContext(); 
>
> 2）在HttpServlet中直接获取 
> this.getServletContext() 
>
> 3）在其他方法中，通过HttpServletRequest获得 
> request.getSession().getServletContext();
>
> webApplicationContext和sercletContext
>
> https://www.iteye.com/blog/blessht-2121845
>
> ①启动项目时触发contextInitialized方法，该方法就做一件事：通过父类contextLoader的initWebApplicationContext方法创建Spring上下文对象。
>
> ②initWebApplicationContext方法做了三件事：创建WebApplicationContext；加载对应的Spring文件创建里面的Bean实例；将WebApplicationContext放入ServletContext（就是Java Web的全局变量）中。
>
> ③createWebApplicationContext创建上下文对象，支持用户自定义的上下文对象，但必须继承自ConfigurableWebApplicationContext，而Spring MVC默认使用ConfigurableWebApplicationContext作为ApplicationContext（它仅仅是一个接口）的实现。
>
> ④configureAndRefreshWebApplicationContext方法用于封装ApplicationContext数据并且初始化所有相关Bean对象。它会从web.xml中读取名为contextConfigLocation的配置，这就是spring xml数据源设置，然后放到ApplicationContext中，最后调用传说中的refresh方法执行所有Java对象的创建。
>
> ⑤完成ApplicationContext创建之后就是将其放入ServletContext中，注意它存储的key值常量。

3. 接使用spring mvc中的**HandlerInterceptor**或者**HandlerInterceptorAdapter** 来替换Filter:

```java
public class WeiXinInterceptor implements HandlerInterceptor {
    @Autowired
    private UsersService usersService;   
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // TODO Auto-generated method stub
        return false;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)
            throws Exception {
        // TODO Auto-generated method stub
        
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // TODO Auto-generated method stub
        
    }
}
```

# 公共jar @Configuration 失效

springboot项目中，除非是在spring.factory中的autoconfiguration实例化的或者是@import导入的类，**否则需要用@ComponentScan扫描加入实例化列表**（若是全部依赖都扫描，会极大增加项目启动时间）

**@Import 是 Spring 基于 Java 注解配置的主要组成部分，@Import 注解提供了类似 @Bean 注解的功能。Import可以配合 Configuration, ImportSelector, ImportBeanDefinitionRegistrar 来使用，也可以用于一个普通类的导入。**

### ImportSelector接口

```java
String[] selectImports(AnnotationMetadata importingClassMetadata)

返回一个包含了类全限定名的数组,这些类会注入到Spring容器当中

Predicate< String > getExclusionFilter()

返回一个谓词接口，该方法制定了一个对类全限定名的排除规则来过滤一些候选的导入类，默认不排除过滤。该接口可以不实现。
```

### ImportBeanDefinitionRegistrar接口

该接口的目的是实现类的动态注入，同样的，先来看看ImportBeanDefinitionRegistrar接口的定义。

一共定义了两个同名方法，**都是用于将类的BeanDefinition注入**。

唯一的区别就是，2个参数的方法，只能手动的输入beanName，而3个参数的方法，可以利用BeanNameGenerator根据beanDefinition自动生成beanName

### 源码分析

在ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry中，实现了对各种配置类按

https://blog.csdn.net/gongsenlin341/article/details/113281596

> 1. @Component(它把所有的标识@Component注解的class加载进来，而@Configuration，@RestController，@Service，@Repository等都包含@Component)
> 2. @PropertySource
> 3.  @ComponentScan(刚开始有sourceClass为启动类的SpringApplication.run(xxx)中的xxx时，按他的@ComponentScan扫描，没有则默认，通过包含@Compent的注解，如1的，都是按扫描进来的顺序加载BeanDefinition，没有特别的优先顺序)
> 4.  @Import
> 5. @ImportResource 
> 6. default methods on interfaces
> 7. superclass, if any

加载到configurationClasses集合中，然后执行loadBeanDefinitions将configurationClasses集合当中类信息加载到Spring容器当中（此时还没实例化），并且从 importBeanDefinitionRegistrars 缓存当中拿到所有的ImportBeanDefinitionRegistrar并执行registerBeanDefinitions方法。

最后生成的BeanDefinition会交由BeanFactory在实例化bean前，处理BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor接口的针对bean实例化前的前置处理（beanFactory的后置处理）

其中这两个处理器的处理顺序为：

> 整个factory后置处理器的执行顺序
>
> https://blog.csdn.net/gongsenlin341/article/details/108433119
>
> 程序员手动添加的 并且是实现了BeanDefinitionRegistryPostProcessor的接口的后置处理器。详情参考3.2.2.1
> spring自带的后置处理器，也就是ConfigurationClassPostProcessor。详情参考3.2.2.2（**这是上面的交由spring管理的bean扫描的处理类**）
> Spring扫描的并且实现了BeanDefinitionRegistryPostProcessor接口和Ordered接口的后置处理器。详情参考3.2.2.3
> Spring扫描的并且实现了BeanDefinitionRegistryPostProcessor接口但没有实现Ordered接口的后置处理器。详情参考3.2.2.4
> 处理上述后置处理器中的父接口BeanFactoryPostProcessor的逻辑。详情参考3.2.2.5
> 程序员手动添加的并且实现了BeanFactoryPostProcessor接口的后置处理器。详情参考3.2.2.6
> Spring扫描的，并且实现了BeanFactoryPostProcessor接口的后置处理器。按照实现了Priority接口、Ordered接口和没有实现这两个接口的顺序执行。详情参考3.2.2.7

而他们在bean的处理顺序如图：

![image-20201030134546745](https://raw.githubusercontent.com/eternal-heathens/picgoBeg/master/JavaImages/image-20201030134546745.png)
