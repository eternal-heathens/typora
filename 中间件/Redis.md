# Redis

### 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题

缓存穿透：

### Memcache与Redis的区别都有哪些？

### 单线程的redis为什么这么快

### Redis 持久化机制

### redis的数据类型，以及每种数据类型的使用场景

### redis的过期策略以及内存淘汰机制

### Redis 集群方案应该怎么做？都有哪些方案？

### Redis 为什么是单线程的

### 有没有尝试进行多机redis 的部署？如何保证数据一致的？

### 对于大量的请求怎么样处理

### redis的过期策略以及内存淘汰机制

### 讲解下Redis线程模型

### Redis事务

### Redis分布式锁



# 哨兵模式和集群模式

https://www.cnblogs.com/itplay/p/11098990.html

https://zhuanlan.zhihu.com/p/144479894

## 哨兵模式

哨兵模式是redis`高可用`的实现方式之一
使用一个或者多个哨兵(Sentinel)实例组成的系统，对redis节点进行监控，在主节点出现故障的情况下，能将从节点中的一个升级为主节点，进行故障转义，保证系统的可用性。

![image-20220220181509139](https://raw.githubusercontent.com/eternal-heathens/picgoBeg/master/JavaImages/image-20220220181509139.png)

### 哨兵们是怎么感知整个系统中的所有节点(主节点/从节点/哨兵节点)的[#](https://www.cnblogs.com/itplay/p/11098990.html#1862401656)

1. 首先主节点的信息是配置在哨兵(Sentinel)的配置文件中
2. 哨兵节点会和配置的主节点建立起两条连接`命令连接`和`订阅连接`
3. 哨兵会通过`命令连接`每10s发送一次`INFO`命令，通过`INFO命令`，主节点会返回自己的run_id和自己的`从节点信息`
4. 哨兵会对这些从节点也建立两条连接`命令连接`和`订阅连接`
5. 哨兵通过`命令连接`向从节点发送`INFO`命令，获取到他的一些信息
   a. run_id
   b. role
   c. 从服务器的复制偏移量 offset
   d. 等
6. 因为哨兵对与集群中的其他节点(主从节点)当前都有两条连接，`命令连接`和`订阅连接`
   a. 通过`命令连接`向服务器的`_sentinel:hello`频道发送一条消息，内容包括自己的ip端口、run_id、配置纪元(后续投票的时候会用到)等
   b. 通过`订阅连接`对服务器的`_sentinel:hello`频道做了监听，所以所有的向该频道发送的哨兵的消息都能被接受到
   c. 解析监听到的消息，进行分析提取，就可以知道还有那些别的哨兵服务节点也在监听这些主从节点了，更新结构体将这些哨兵节点记录下来
   d. 向观察到的其他的哨兵节点建立`命令连接`----没有`订阅连接` 

### 主观下线（单个哨兵模式）

哨兵(Sentinel)节点会每秒一次的频率向建立了命令连接的实例发送PING命令，如果在`down-after-milliseconds`毫秒内没有做出有效响应包括(PONG/LOADING/MASTERDOWN)以外的响应，哨兵就会将该实例在本结构体中的状态标记为`SRI_S_DOWN`主观下线

### 客观下线（多哨兵模式）

当一个哨兵节点发现主节点处于主观下线状态是，会向其他的哨兵节点发出询问，该节点是不是已经主观下线了。如果超过配置参数`quorum`个节点认为是主观下线时，该哨兵节点就会将自己维护的结构体中该主节点标记为`SRI_O_DOWN`客观下线
询问命令`SENTINEL is-master-down-by-addr <ip> <port> <current_epoch> <run_id>`

| 参数          | 意义                                                         |
| ------------- | ------------------------------------------------------------ |
| ip/port       | 当前认为下线的主节点的ip和端口                               |
| current_epoch | 配置纪元                                                     |
| run_id        | *标识仅用于询问是否下线 有值标识该哨兵节点希望对方将自己设置为leader `询问时用*，选举时用run_id` |

### 故障迁移

1. 在从节点中挑选出新的主节点
   a. 通讯正常
   b. 优先级排序
   c. 优先级相同是选择offset最大的
2. 将该节点设置成新的主节点 `SLAVEOF no one`,并确保在后续的INGO命令时，该节点返回状态为master
3. 将其他的从节点设置成从新的主节点复制, `SLAVEOF命令`
4. 将旧的主节点变成新的主节点的从节点

### 优缺点

- 优点
  高可用，在主节点故障时能实现故障的转移
- 缺点：好像没办法做到水平拓展，如果内容很大的情况下

## 集群模式

官方提供的分布式方案(槽指派/重新分片/故障转移)

``` java

//整体
struct clusterState{
  clusterNode *mySelf;
  ....
  dict *nodes;  //集群内的所有节点
}

// 单个节点
struct clusterNode {
  char name[];
  char ip[];
  int port;
  clusterLink *link;  //保存节点间，连接的信息
  int flags;    //状态标记
}

//节点间连接的信息
struct clusterLink{
  mstime_t ctime;  //创建时间
  int fd; //tcp套接字描述符
  sds sndbuf;  // 输出缓存区
  sds rcvbuf;  //输入缓存区
  struct clusterNode *node;
}


```

![img](https://raw.githubusercontent.com/eternal-heathens/picgoBeg/master/JavaImages/1198522-20190701133957761-379838070.jpg)

### 哈希槽概念

redis集群可以被分为16384个槽，只有这些槽全被指派了处理的节点的情况下，集群的状态才能是上线状态(ok)

在Redis集群中，大体也是通过相同的机制定位服务器的，只是Redis集群的哈希槽大小为（214=16 384），也就是取值范围为区间[0, 16383]，最多能够支持16 384个节点，Redis设计师认为这个节点数已经足够了。(对于key，Redis集群会采用CRC16算法计算key的哈希值)

### Redis集群工作原理

这里假设有3个Redis主服务器（或者称为节点），用来存储缓存的数据，每一个主服务器都有一个从服务器，用来复制主服务器的数据，保证高可用。其中哈希槽分配如下。

- Redis主服务器1：分配哈希槽区间为[0, 5460]。
- Redis主服务器2：分配哈希槽区间为[5461, 10922]。
- Redis主服务器3：分配哈希槽区间为[10923, 16383]。

这样通过CRC16算法求出key的哈希值，再对16 384求余数，就知道n会落入哪个哈希槽里，进而决定数据存储在哪个Redis主服务器上。

注意，集群中各个Redis服务器不是隔绝的，而是相互连通的，采用的是PING-PONG机制，内部使用了二进制协议优化传输速度和带宽

![image-20220220204928209](https://raw.githubusercontent.com/eternal-heathens/picgoBeg/master/JavaImages/image-20220220204928209.png)

客户端与Redis节点是直连的，不需要中间代理层，并且不需要连接集群所有节点，只需连接集群中任何一个可用节点即可。在Redis集群中，要判定某个主节点不可用，需要各个主节点进行投票，如果半数以上主节点认为该节点不可用，该节点就会从集群中被剔除，然后由其从节点代替，这样就可以容错了。因为这个投票机制需要半数以上，所以一般来说，要求节点数大于3，且为单数。因为如果是双数，如4，投票结果可能会为2:2，就会陷入僵局，不利于这个机制的执行。

### 集群失效情况

在某些情况下，Redis集群会不可用，当集群不可用时，所有对集群的操作做都不可用。那么什么时候集群不可用呢？一般来说，分为两种情况。

- 如果某个主节点被认为不可用，并且没有从节点可以代替它，那么就构建不成哈希槽区间[0, 16383]，此时集群将不可用。
- 如果原有半数以上的主节点发生故障，那么无论是否存在可代替的从节点，都认为该集群不可用。

### 故障转移

#### 发现故障节点

1. 集群内的节点会向其他节点发送PING命令，检查是否在线
2. 如果未能在规定时间内做出PONG响应，则会把对应的节点标记为疑似下线
3. 集群中一半以上`负责处理槽的主节点`都将主节点X标记为疑似下线的话，那么这个主节点X就会被认为是`已下线`
4. 向集群广播主节点X`已下线`,大家收到消息后都会把自己维护的结构体里的主节点X标记为`已下线`

#### 从节点选举

1. 当从节点发现自己复制的主节点已下线了，会向集群里面广播一条消息，要求所有有投票权的节点给自己投票(`所有负责处理槽的主节点都有投票权`)
2. 主节点会向第一个给他发选举消息的从节点回复支持
3. 当支持数量超过N/2+1的情况下，该从节点当选新的主节点

#### 故障的迁移

1. 新当选的从节点执行 `SLAVEOF no one`,修改成主节点
2. 新的主节点会撤销所有已下线的老的主节点的槽指派，指派给自己
3. 新的主节点向集群发送命令，通知其他节点自己已经变成主节点了，负责哪些槽指派
4. 新的主节点开始处理自己负责的槽的命令

### 集群模式缺点

1. 需要更多的服务器

### 迁移槽时查询处理

# ![img](https://raw.githubusercontent.com/eternal-heathens/picgoBeg/master/JavaImages/1198522-20190701134130420-1275560625.jpg)分布式缓存实践

## 大对象的缓存

1. 将大对象按字段划分成多个部分，使用（hash结构）存储对应部分内容
2. 若是某个字段的值也是大对象，我们可以将其拆分为field3_1, field3_2, …, field3_n，分段保存字符串，然后读取的时候，也分段读取即可。

## 缓存穿透、并发和雪崩

### 缓存穿透

当客户端通过一个键去访问缓存时，缓存没有数据，跟着又去访问数据库，数据库也没有数据，这时因为数据库返回也为空，所以不会将该数据放到缓存中，我们把这样的情况称为**缓存穿透**

![preview](https://raw.githubusercontent.com/eternal-heathens/picgoBeg/master/JavaImages/v2-b2a8a866fcd0b977759d3e96eed75ef1_r.jpg)

### **缓存并发（单个key-value失效）**

在使用缓存的过程中，我们往往还会设置超时时间，当数据超时的时候，就不能从缓存中读取数据了，而是到数据库中读取。有些数据是热点数据，例如我们最畅销的产品，假如在高并发期间，这个产品和它的关联信息在缓存中超时失效了，就会导致大量的请求访问数据库，给数据库带来很大的压力，甚至可能导致数据库宕机，类似这样的情况，我们称为**缓存并发**

![image-20220220210813007](https://raw.githubusercontent.com/eternal-heathens/picgoBeg/master/JavaImages/image-20220220210813007.png)

**解决方案**

- **限流：**也就是防止过多的请求来访问缓存系统，从而导致压垮数据库，例如使用Resilience4j进行限流，但是这会影响并发线程数量。
- **加锁：**对缓存数据加锁，使得线程只能一条条地通过去访问，而不能并发访问，这样就能避免缓存并发的现象，但是分布式锁比较难以实现，所以一般来说我们不会考虑这个办法。
- **错峰失效：网站一般是在上网高峰期或者热门商品抢购时，才会出现高并发现象，而这是有规律的，所以可以自己设置那些需要经常访问的缓存，错过这段时间失效，一般就不会出现缓存并发的现象了，这个做法的成本相对低，也容易实现，所以我比较推荐它。**

**缓存雪崩（多个key-value失效）**

我们在启动系统的时候，一般会把最常用的数据放入缓存中，并且设置一个固定的超时时间，这便是我们常说的预热数据，它有助于系统性能的提高。但是，因为设置了一个固定的超时时间，所以会导致在某个时间点有**大量缓存的键值对**数据超时，如果在这个时间点出现高并发，就会导致请求大量访问数据库，造成数据库压力过大，甚至宕机

![img](https://raw.githubusercontent.com/eternal-heathens/picgoBeg/master/JavaImages/v2-936e7e9c5f7967c33f291c919a9b943b_720w.jpg)
