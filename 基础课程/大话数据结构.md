###  数据结构绪论

应用数据结构的前提是，你的原始数据符合数据结构的特性，而且在没有更好的解法的情况下应用他，其本质上也是一种特殊的排序，其中的增删查改需要满足其特殊的结构而设计（里面的许多相关操作都结合了动态规划的等思想了），若是一般情况或者你有更好的解法，完全可以自己解决，而一般情况下先排序后查改的效率会更高。

#### 数据结构起源

* 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。

#### 基本概念和术语

* 数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。lllllllllllllllllll
* 数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称作记录。

* 数据项：一个数据元素可以由若干个数据项组成（数据项是不可分割的最小单位）
* 数据对象：是性质相同的数据元素集合，是数据的子集
* 结构：不同数据元素之间不是独立的，而是存在特定的关系
* 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合

#### 逻辑结构与物理结构

* 逻辑结构：是指数据对象中数据元素之间的相互关系

> 集合结构：集合结构中的数据元素除了同属于一个外，他们之间没有其他关系
>
> 线性结构：一对一
>
> 树形结构：一对多
>
> 图形结构：多对多



* 物理结构：是指数据的逻辑结构在计算机中的存储形式，**数据的存储结构应正确反映数据元素之间的逻辑关系，这才是最为关键的**

##### 顺序存储和链式存储

* 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致
* 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的

#### 抽象数据类型

* 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总和。 

  > ![image-20200427204331448](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200427204331448.png)

* 抽象数据类型：是指一个数据模型及定义在该模型上的一组操作

  > “抽象”的意义在于数据类型的数学抽象特性：eg：在不同系统中“整形”类型的实现方式可能不同，但是，由于其数据特性相同。因此：“抽象9”的意义在于数据类型的数据抽象特性

抽象数据类型和数据类型在实质上是一个概念，只不过是对数据类型的进一步抽象，不仅限于各种不同的计算机处理器中已经实现的数据类型，还包括为解决更为复杂的问题而由用户自定义的复杂数据类型。

![image-20200428175736917](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200428175736917.png)

----




### 算法

* 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或读个操作。

* 五个基本特性：输入、输出、有穷性、确定行和可行性。

* 好的算法：正确性、可读性、健壮性、高效率和低存储量

#### 算法效率的度量方法

##### 事后统计方法 

*  de:通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较（一般可以的话不采纳）

> 缺陷：1. 必须依据算法实现编制好程序
>
> ​	2. 时间的比较依赖计算机硬件和软件等环境因素
>
>    			3. 与规模有关



##### 事前分析估算方法

* de:在计算机程序编制前，依据统计方法对算法进行估算

* 计算机上运行时所消耗的时间取决于下列因素：

  > 1. 算法采用的策略、方法
  > 2. 编译产生的代码质量（软件）
  > 3. 问题的输入规模
  > 4. 机器执行指令的速度（硬件）
  >
  > * 抛开软硬件，一个程序的运行时间，依赖于算法的好坏和问题的输入规模

#### 函数的渐近增长

* de:给定连个函数f（n）和g（n），如果存在一个整数N，使得对于所有的n>N，f（n）总是比g（n）大，那么，我们说f（n）的增长渐快于g（n）

* 判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数

#### 算法时间复杂度

* de：在进行算法分析时，语句总的执行次数T（n）时关于问题规模n的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级。算法的时间复杂度，也就是算法的时间度量，记作：T(n) = O(f（n）)。它表示随问题规模n的增大，算法执行时间的增长率和f（n）的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f（n）时问题规模n的某个函数。

> 推导大O阶：（注意加强数学知识里的数列知识）
>
> 1. 用常数1取代运行时间中的所有加法常数
> 2. 在修改后的运行次数函数中，只保留最高阶项
> 3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数

##### 常数阶

无论f（n） =  k（常数）为多少，按推导大O阶的方法，第一步，把k换成1，

**这种与问题的大小无关（n的多少），执行时间恒定** 的算法，我们称之为具有O（1）的时间复杂度，又叫常数阶。（分支结构也是）

##### 线性阶

O（n）

##### 对数阶

O（logn）

##### 平方阶

O（n^2）

#### 常见的时间复杂度

![image-20200428145650361](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200428145650361.png)

#### 最坏情况与平均情况

* 最坏情况运行时间（最重要需求），对于时间复杂度，一般没有特殊说明，就是**最坏时间复杂度**
* 平均运行时间：所有情况中最有意义的，因为它是期望的运行时间

#### 算法空间复杂度

计算公式：S（n） = O（f（n）），其中n为问题的规模，f（n）为语句关于n所占存储空间的函数。

* 若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若相对于 数据量是个常数，则称此算法为原地工作，O（1）

---



### 线性表（List）

#### 抽象数据结构

![image-20200521135427762](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521135427762.png)![image-20200521135451450](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521135451450.png)

* de：零个或多个数据元素的有限序列
* 只有一个直接后继/前驱元素
* 线性表元素的个数n（n>=0）定义为线性表的长度，当n = 0时，称为空表

* 线性表的抽象数据类型：

  > ![image-20200428195241427](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200428195241427.png)
  >
  > ![image-20200428195319919](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200428195319919.png)

#### 顺序存储结构

* de：用一段地址连续的存储单元依次存储线性表的数据元素
* ![image-20200428210439255](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200428210439255.png)

#### 链式存储结构

* 为了表示每个数据a（i）与其直接后继数据元素a（i+1）之间的逻辑关系，对数据元素a（i）来说，除了存储其本身的信息之外（**数据域**），还需存储一个指示其直接后续的信息（**指针域**）。这两部分信息组成数据元素a（i）的存储映像，称为**结点（Node）**

* n个结点（a（i）的存储映像）链结成一个链表，即为线性表（a(1),a(2)···,a(n)）的链式存储结构，因为此链表的每个结点（只包含一个指针域），所以叫做单链表。


* 链表中第一个结点的存储位置叫做头指针（必须有）
> ![image-20200429001429196](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200429001429196.png)

* 在单链表的第一个结点前附设一个结点，称为头节点
> ![image-20200429001522534](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200429001522534.png)

#### 头指针与头结点的异同

![image-20200429002032550](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200429002032550.png)

#### 单链表和顺序存储的优缺点

![image-20200430181259365](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200430181259365.png)

#### 静态链表

* 用数组代替指针，来描述单链表。
* 数组的元素都是由两个数据域与构成，data（数据元素）和cur（next指针）。
* 数组的第一个元素为备用链表（未被使用的数组元素）的cur存放第一个结点的下标，最后一个元素的cur存放第一个有数值的元素的下标（头结点）。

![image-20200501104049680](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200501104049680.png)

##### 插入

![image-20200501113717395](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200501113717395.png)

##### 静态链表优缺点

![image-20200501114145469](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200501114145469.png)

#### 循环链表

* 将单链表中终端结点的指针由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为**单循环链表**，简称循环链表
* 为了使空链表与非空链表处理一致

> ![image-20200501120313659](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200501120313659.png)
>
> 
>
> 若需要用O（1）的时间复杂度访问尾指针(rear)和头指针(rear->next->next)可以用指向终端节点的尾指针来表示循环链表.



#### 双向链表

* 双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。

![image-20200501191913474](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200501191913474.png)

* 插入（顺序很重要）

![image-20200501214535494](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200501214535494.png)

#### 总结
![image-20200501214914636](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200501214914636.png)

### 栈与队列

#### 栈的定义

* 栈(STACK)使限定仅在表尾/链表头（顺序存储/链式）进行插入和删除操作的线性表

* 允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构。
* 栈的插入操作，叫做进栈，也称压栈、入栈
* 栈的删除操作，叫做出栈，也有的叫做弹栈

* 最先进栈的不一定最后出栈

  > 栈对线性表的插入和删除的位置进行了限制，并没有元素进出的时间进行限制（若后进的时间比先进的出栈晚就会符合上述条件），只要保证栈顶元素出栈就可以。

#### 栈的抽象数据类型

![image-20200513143147881](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513143147881.png)

#### 栈的顺序存储结构及实现

![image-20200513144946493](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513144946493.png)

#### 两栈共享空间

**同一类型才行**

* 一个栈的栈底为数组的始端，及下标为0处（top1==-1时为空），另一个栈为栈的末端，即下标为数组长度n-1处（top==n时为空）
* top+1==top2时栈满

![image-20200513145609579](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513145609579.png)

#### 栈的链式存储结构及实现

* 由于栈顶在头部了，所以对于链栈来说，是不需要头结点的
* ![image-20200513151403741](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513151403741.png)
* 链栈代码结构

![image-20200513151346758](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513151346758.png)

#### 栈的应用-递归

##### 斐波那契数列的实现

![image-20200513155425573](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513155425573.png)

* 递归的定义：拔一个直接调用的自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数

* 迭代实现：（自底向上，循环结构，不需要额外的空间和反复调用函数）

  ![image-20200513160034696](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513160034696.png)

* 使用递归实现：（自顶向下再向上，选择结构，额外的空间和反复调用函数）

![image-20200513160158141](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513160158141.png)

#### 栈的应用---四则运算表达式求值

##### 逆波兰式

* 不需要括号的后缀表达法称为**逆波兰式（后缀表达式：所有的符号都是在要运算数字的后面出现）**

* 规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。

##### 中缀表达式转后缀表达式

* 标准的四则运算表达式（eg：9+（3-1）*3+10/2），为**中缀表达式**，因为所有的运算符号都在两个数字中间

* 从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，是右括号或优先级低于找顶符号（乘除优先加减），弹出所有优先级大于或者等于该运算符的栈顶元素，然后将该运算符入栈，最终将栈中的元素依次出栈，输出。

* 转化方式有三种：

  首先假设我们需要转化的中缀表达式为：

  **a + b \* c + ( d \* e + f ) \* g**

  第一种：基于堆栈的算法

  1. 从左到右扫描每一个字符。如果扫描到的字符是操作数（如a、b等），就直接输出这些操作数。

     [![c++堆栈的应用：中缀表达式转化为后缀表达式](https://imgsa.baidu.com/exp/w=500/sign=bf0ad010e6c4b7453494b716fffc1e78/03087bf40ad162d9478c34251cdfa9ec8a13cdad.jpg)](http://jingyan.baidu.com/album/a378c960fb7be9b3282830b2.html?picindex=2)

  2. 如果扫描到的字符是一个操作符，分三种情况：

     （1）如果堆栈是空的，直接将操作符存储到堆栈中（push it）

     （2）如果该操作符的优先级大于堆栈出口的操作符，就直接将操作符存储到堆栈中（push it）

     （3）如果该操作符的优先级低于堆栈出口的操作符，就将堆栈出口的操作符导出（pop it）, 直到该操作符的优先级大于堆栈顶端的操作符。将扫描到的操作符导入到堆栈中（push）。

     [![c++堆栈的应用：中缀表达式转化为后缀表达式](https://imgsa.baidu.com/exp/w=500/sign=298f8159382ac65c67056673cbf2b21d/4ec2d5628535e5ddf419f8e67bc6a7efce1b62d5.jpg)](http://jingyan.baidu.com/album/a378c960fb7be9b3282830b2.html?picindex=3)

     [![c++堆栈的应用：中缀表达式转化为后缀表达式](https://imgsa.baidu.com/exp/w=500/sign=c92740311230e924cfa49c317c086e66/0df3d7ca7bcb0a463c30d6006663f6246b60affd.jpg)](http://jingyan.baidu.com/album/a378c960fb7be9b3282830b2.html?picindex=4)

  3. 如果遇到的操作符是左括号"（”，就直接将该操作符输出到堆栈当中。该操作符只有在遇到右括号“)”的时候移除。这是一个特殊符号该特殊处理。

     [![c++堆栈的应用：中缀表达式转化为后缀表达式](https://imgsa.baidu.com/exp/w=500/sign=cecd97164c34970a4773102fa5cad1c0/38dbb6fd5266d0166f3ac1119a2bd40735fa35e3.jpg)](http://jingyan.baidu.com/album/a378c960fb7be9b3282830b2.html?picindex=5)

     [![c++堆栈的应用：中缀表达式转化为后缀表达式](https://imgsa.baidu.com/exp/w=500/sign=f2199c0a7e8da9774e2f862b8050f872/63d0f703918fa0ecb0733b342b9759ee3d6ddb57.jpg)](http://jingyan.baidu.com/album/a378c960fb7be9b3282830b2.html?picindex=6)

     [![c++堆栈的应用：中缀表达式转化为后缀表达式](https://imgsa.baidu.com/exp/w=500/sign=ab9ee08bb4014a90813e46bd99763971/a8ec8a13632762d0428afb86adec08fa513dc657.jpg)](http://jingyan.baidu.com/album/a378c960fb7be9b3282830b2.html?picindex=7)

  4. 如果扫描到的操作符是右括号“）”，将堆栈中的操作符导出（pop）到output中输出，直到遇见左括号“（”。将堆栈中的左括号移出堆栈（pop ）。继续扫描下一个字符

     [![c++堆栈的应用：中缀表达式转化为后缀表达式](https://imgsa.baidu.com/exp/w=500/sign=1ab8d23196504fc2a25fb005d5dce7f0/6d81800a19d8bc3e84a358f38f8ba61ea8d3455b.jpg)](http://jingyan.baidu.com/album/a378c960fb7be9b3282830b2.html?picindex=8)

  5. 如果输入的中缀表达式已经扫描完了，但是堆栈中仍然存在操作符的时候，我们应该讲堆栈中的操作符导出并输入到output 当中。

     [![c++堆栈的应用：中缀表达式转化为后缀表达式](https://imgsa.baidu.com/exp/w=500/sign=28d1fd86adec08fa260013a769ef3d4d/023b5bb5c9ea15cee901b930bb003af33a87b218.jpg)](http://jingyan.baidu.com/album/a378c960fb7be9b3282830b2.html?picindex=9)

     [![c++堆栈的应用：中缀表达式转化为后缀表达式](https://imgsa.baidu.com/exp/w=500/sign=05e5c8cb701ed21b79c92ee59d6eddae/aec379310a55b31969b5db4c4ea98226cffc17be.jpg)](http://jingyan.baidu.com/album/a378c960fb7be9b3282830b2.html?picindex=10)

  第二种：括号法，这种真的很简单啊，好记又简单

     1：按照运算符的优先级对所有的运算单位加括号~

     式子变成拉：（（a+（b*c））+（（（d*e+f）*g））

  ​    2：转换前缀与[后缀表达式](https://www.baidu.com/s?wd=后缀表达式&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)

     前缀：把运算符号移动到对应的括号前面

     则变成拉：+(+(a*(bc))*(+(*(de)f)+g))

     把括号去掉：++a*bc*+*def+g 前缀式子出现

     后缀：把运算符号移动到对应的括号后面

     则变成拉：((a(bc)*)+(((de)*f)+g)*)+

     把括号去掉：abc*+de*f+g *+后缀式子出现

  第三种：利用语法树

  

#### 队列的定义

* 队列（queue）是只允许一段进行插入操作，而在另一端进行删除操作的线性表
* 队列是一种先进先出（First In First Out）的线性表，即**FIFO**，允许插入的一端成为队尾，允许删除的一端称为队头。

#### 队列的抽象数据类型

![image-20200513175346725](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513175346725.png)

#### 循环队列

##### 顺序存储

* 为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向队头元素，rear指针指向队尾元素的下一个位置。

![image-20200513180641676](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513180641676.png)

![image-20200513180715466](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513180715466.png)

##### 循环队列定义

* 为了解决上面导致的假溢出问题，我们把队列做成了头尾相接的顺序存储结构称为循环队列。

  ![image-20200513191323518](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513191323518.png)

* front == rear时，无法判断是空是满

  > 一：设置一个标志变量flag，当front == rear ,且flag==0时为队列空，front = rear,且flag =1 时为队列满。
  >
  > 二：当队列空时，front == rear，当队列满时，修改其条件，保留一个元素空间，队列满的条件时（rear+1）%QueueSize == front通用的计算队列长度公式为：(rear-front+QueueSize)%QueueSize = QueueLength

#### 队列的链式存储结构及实现

* 线性表的单链表，只能尾进头出

  ![image-20200513210655850](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513210655850.png)

### 串

#### 串的定义

* 串（String）是由零个或多个字符组成的有限序列，又名叫字符串

* 发展历史：ASCII(7)->ASCII(8)->Unicode(16)

![image-20200513214902901](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513214902901.png)

#### 串的抽象数据类型

* 线性表更关注的是单个元素的操作（eg：查找一个元素、插入或删除一个元素），但串中更多的是查找子串位置，得到指定位置子串等操作

![image-20200513215228409](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513215228409.png)

#### 串的存储结构

##### 顺序存储

![image-20200513232709371](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513232709371.png)

![image-20200513232731046](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200513232731046.png)

##### 链式存储结构

* 一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被沾满时，可以用“#”或其他非串值字符补全。

#### 朴素的模式匹配算法

![image-20200519115635278](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200519115635278.png)

![image-20200519115701296](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200519115701296.png)

* 逐个匹配
* 最好O(1),平均O(n+m)/2,最差(n-m+1)*m*

#### KMP模式匹配

* 我们在朴素的模式匹配算法中，主串的i值是不断地回溯来完成的。
* **KMP模式匹配算法实现**通过取消i的回溯来完成。

> 1. 与T[1]不同的字符全都不需要回溯
> 2. T[j-K+1]···T[j-1]与T[1]···T[k-1]相同的，也不需要回溯

* KMP模式匹配算法实现j值得变化与主串其实没什么关系，关键就取决于T串得结构中是否有重复的问题。

![image-20200518231354063](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200518231354063.png)

* T[j]中哪个与S[i]不等，则取哪个next[j]值，next[j]指的是T串中第next[j]个 开始与S串中的第i个字符比较（存储是从1开始的）

![image-20200518233541245](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200518233541245.png)

##### KMP模式匹配算法实现

![image-20200519113349229](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200519113349229.png)

![](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200519001917343.png)

![image-20200519001925590](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200519001925590.png)

get——next->O（m），index——KMP->O(n), 总的O（n+m）

##### KMP模式匹配算法改进

* **KMP模式匹配算法实现**通过取消i的回溯来完成。

> 1. 与T[1]不同的字符全都不需要回溯
> 2. T[j-K+1]···T[j-1]与T[1]···T[k-1]相同的，也不需要回溯
> 3. 若T[1]···T[k-1]若是相同的字符，上述算法的j需一个一个回溯，可将nextval[i]= nextval[j]来避免这步（Index_kmp），nextval中j仍在计数，相同的继续计数，不同的因和前面相同，跳转后判定仍会不同，即直接跳到第一个相同即可

* 减少 j =  nextval[j]的重复次数

![image-20200603134945484](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603134945484.png)

![image-20200521115223069](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521115223069.png)

![image-20200521115236025](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521115236025.png)

![image-20200519115249713](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200519115249713.png)

![image-20200519115255646](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200519115255646.png)

### 树 

#### 树的定义

* 树（Tree）是n（n>=0）个节点的有限集。n= 0时称为空树。在任意一颗非空树中：（1）有且仅有一个特定的称为**根（Root）**的结点；（2）当n>1时，其余结点可分为m（m>0）个互不相交的有限集T1、T2····Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。

> ![image-20200521131657223](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521131657223.png)

##### 结点分类

* 结点拥有的**子树数**称为结点的**度**
* 度为**0**的结点称为**叶节点（Leaf）**或终端结点
* 度不为0的结点称为非终端节点或分支结点
* **树的度**是树内各节点度的**最大值**

##### 结点间关系

* 结点的**子树的根**称为该节点的**孩子（Child）**，**结点为孩子的双亲（Parent）**
* 同一个双亲的孩子之间互称**兄弟（Sibling）**
* 结点的**祖先**是**从根到该节点所经分支上的所有结点**，该节点的子树中的任一结点都称为该节点的**子孙**

##### 树的其他相关概念

* 层次（从根开始）
* 堂兄弟（不同的双亲在同一层）

* 深度（Depth）/高度（树中结点的最大层次）

![image-20200521133821373](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521133821373.png)

* 有序树（树中结点的各子树看成从左至右是有次序的，不能互换的），否则为无序树
* 森林（Forest）是m（m>=0）棵互不相交的树的集合

#### 树的抽象数据类型

![image-20200521135551803](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521135551803.png)

#### 树的存储结构

* 数组+链表

##### 双亲表示法

![image-20200521174610320](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521174610320.png)

![image-20200521174618411](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521174618411.png)

![image-20200521174628410](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521174628410.png)

* 根据需要可以加长子域、右兄弟域等等

##### 孩子表示法

* 多重链表表示法

一、根据树的度来设置指针域的个数（空间浪费）

![image-20200521174950865](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521174950865.png)

二、专门取一个位置来存储结点指针域的个数（时间浪费）

![image-20200521175130525](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521175130525.png)

* 孩子表示法

> 把每个结点的孩子结点排列起来，以单链表作存储结构，n个头指针又组成一个线性表，采用顺序存储结构，放入一维数组中

![image-20200521180113858](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521180113858.png)

* 孩子结点

![image-20200521180125411](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521180125411.png)

* 表头结点

![image-20200521180129942](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521180129942.png)

![image-20200521182243607](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521182243607.png)

![image-20200521182251758](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521182251758.png)

* 双亲孩子表示法

  ![image-20200521182413430](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521182413430.png)

##### 孩子兄弟表示法

* 从树的结点的兄弟出发，**更高的利用空间**，结合了 **多重链表表示法+双亲孩子表示法的优点**（降低了多重2的时间浪费和提高了双亲孩子的空间）

* 任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。

![image-20200521184330084](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521184330084.png)

![image-20200521184423360](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521184423360.png)

![image-20200521184404869](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521184404869.png)

* **经过这个表示法，将一颗复杂的树变成了二叉树，便于对树的算法实现**

#### 二叉树的定义

* 若这种在某个阶段都是两种结果的情形，可以用二叉树来判定

* 二叉树（Binary Tree）是n（n>=0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成

##### 二叉树特点

* 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。
* 左右子树次序不能任意颠倒
* 即使只有一棵子树，也要区分左右

##### 特殊二叉树

* 斜树（只有左子树：左斜，反之，右斜）
* 满二叉树（所有节点均存在左右子树，所有叶子都在同一层上）
* 完全二叉树：需依序先左后右增加

![image-20200521192747513](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200521192747513.png)

特点：

1. 叶子节点只出现在最下两层

2. 最下层叶子若不满则集中在左部连续位置
3. 倒数第二层，若有叶子，一定在右部连续位置
4. 若结点度为1，只有左孩子
5. 同样结点二叉树，完全二叉树的深度最小

#### 二叉树的性质

1. 在二叉树的第i层上至多有2^(i-1)个结点（i>=1）
2. 深度为k的二叉树至多有(2^k)-1个结点（k>=1）
3. 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1

> 若n1为度1的结点数
>
> T结点总数为：n = n0+n1+n2
>
> 分支线总数 = n-1 = n1+2n2
>
> n0 = n2+1

4. 具有n个结点的完全二叉树的深度为![image-20200522121659081](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200522121659081.png)

   > 深度为k的满二叉树的结点数n= (2^k)-1，取对数

5. ![image-20200522122555631](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200522122555631.png)

#### 二叉树的存储结构

##### 顺序存储

* 顺序存储结构一般只用于完全二叉树（不存在的结点设置为“^”）
* 不然将出现以下情况
* ![image-20200530121517304](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200530121517304.png)

##### 二叉链表

* 二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，称为**二叉链表**

![image-20200525140212452](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200525140212452.png)

![image-20200525140417875](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200525140417875.png)

#### 遍历二叉树

* 二叉树的遍历（traversing binary tree） 是指从根节点出发，按照某种次序一次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。

* 前序遍历：规则是若二叉树为空，则空操作返回，否则先访问根节点（读取值），然后前序遍历左子树，再前序遍历右子树

![image-20200525162727713](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200525162727713.png)

* 中序遍历：若树为空，则空操作返回，否则从根节点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树。

  ![image-20200525163901026](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200525163901026.png)

* 后序遍历：规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根节点。

![image-20200525170407260](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200525170407260.png)

* 层序遍历：规则是若树为空，则空操作返回。否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点的逐个访问。



##### 前序遍历算法

![image-20200525183420123](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200525183420123.png)

##### 中序遍历算法

![image-20200526210203115](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200526210203115.png)

##### 后续遍历算法

![image-20200526210400683](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200526210400683.png)

##### 推导遍历结果

* 若前序遍历数列为ABCDEF，中序遍历CBAEDF

1. 由前序确定树的根节点
2. 再由中序确定根节点的左右子树所包含的数列
3. 由前序数列中根据中序数列分开的左右子树确定根节点子树的左右子树的根节点（左右子树分别在前序数列中最靠近根节点的数字）
4. 循环往复

* 若后序遍历数列和中序数列，则将上述中前序字样换成后序。

#### 二叉树的建立

* 建立二叉树和上述的打印结点类似，只不过打印的地方改成了生成结点、给节点赋值的操作。
* 前序：

![image-20200526214327502](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200526214327502.png)

![image-20200526214338561](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200526214338561.png)

#### 线索二叉树

* 若每个结点都由指向左右孩子的两个指针域，所以一共是2n个指针域。而n个结点的二叉树一共有n-1条分支线数。也就是存在2n-（n-1） = n+1个空指针域。为了利用空间：

* 指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）
* 把二叉树进行中序遍历后，所有空指针域中的rchild改为后继节点，lchild为前驱（即变成了双向链表）
* 为了辨别时左孩子还是前驱，右孩子还是指向后继，设置了ltag和rtag标至

![image-20200527211611976](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200527211611976.png)

![image-20200527212021866](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200527212021866.png)

#####  实现

![image-20200527212132318](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200527212132318.png)

* 线索化：

![image-20200527212511837](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200527212511837.png)

* 若遍历，则再增加一个头结点

![image-20200528151655477](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200528151655477.png)

![image-20200528151703808](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200528151703808.png)

![image-20200528151846716](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200528151846716.png)

* 如果所用的二叉树需经常遍历或查找结点时**需要某种遍历序列中的前驱和后继**，可采用线索二叉树

#### 树、森林与二叉树的转换

* 树转换为二叉树

![image-20200528202520779](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200528202520779.png)

* 森林转换为二叉树

> 1. 把每个树转换为二叉树
> 2. 第一颗树不懂，从第二课二叉树开始，依次把后一颗二叉树的根节点作为前一刻二叉树的根节点的右孩子，用线连接起来。
> 3. ![image-20200528203803665](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200528203803665.png)

* 二叉树转换为树(判断二叉树能够转换成树还是森林只要看二叉树的根节点有没有右孩子：有就是森林，没有就是树)

> 1. 加线：若某结点的左孩子结点存在，则将这个左孩子的所以右子孙作为此节点的孩子。将该节点与这些右孩子结点用线连接起来。
> 2. 去线：删除原二叉树中所有节点与其右孩子结点的连线。
> 3. 层级调整。
> 4. ![image-20200528205403131](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200528205403131.png)

* 二叉树转换为森林（根节点有）

> 1.  从根节点开始，若右孩子存在，则把与右孩子结点删除，再查看分离后的二叉树，重复如此。
> 2. 再将每颗分离后的二叉树转换为树即可。
> 3. ![image-20200528215348472](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200528215348472.png)

##### 树与森林的遍历

> 1. 树和森林的子树不确定性会给存储空间和算法实现带来了负担，继而影响了算法效率。
> 2. 二叉树为两者的简单解决方法。
> 3. 森林分为每棵树遍历，树有先序遍历（先访问森林中第一棵树的根节点）和后序遍历（先依次后根遍历每颗子树，最后再访问根节点）

#### 赫夫曼树及其应用

* 从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作**路径长度**

* 若不带权：树的路径长度就是从树根到每一个结点的路径长之和。
* 若带权：树的带权路径长度为书中所有叶子节点（从结点到树根的路径长度与结点上权的乘积）的带权路径长度之和。

* 带权路径长度WPL最小的二叉树称作赫夫曼树

* 赫夫曼树的赫夫曼算法描述：

> 1. 根据给定的n个权值{w1，w2，··，wn}构成n棵二叉树的集合F={T1，T2···，Tn}，其中每棵二叉树Ti中只有一个带权wi根节点，其左右子树均为空。
> 2. 再F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根节点的权值为其左右子树上根节点的权值之和。
> 3. 在F中删除这两棵树，同时将新得到的二叉树加入F中。
> 4. 重复2和3步骤，直到F只含一棵树为止。

##### 赫夫曼编码

* 设需要编码的字符集为{d1，d2，···，dn}，各个字符在电文中**出现的次数或频率**集合为{w1，w2，···，wn}，以d1，d2，···，dn作为叶子结点，以w1，w2，···，wn作为相应叶子结点，的权值来构造一棵赫夫曼树。规定赫夫曼树***左分支代表0，右分支代表1**，则从根节点到叶子节点所经过的路径组成的0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码。

* 若要设计长短不等的编码，则必须是任一字符都不是另一个字符的编码的**前缀**，这种编码称做**前缀编码**。

#### 红黑树

如果二叉排序树是平衡的，则n个节点的二叉排序树的高度为Log 2^(n+1),其查找效率为O(Log 2^n)，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到n，查找效率为O(n)，退化为顺序查找。一般的，二叉排序树的查找性能在O(Log 2^n)到O(n)之间。因此，为了获得较好的查找性能，就要构造一棵平衡的二叉排序树。

**红黑树不同于平衡二叉树需要全部平衡，仅需要实现局部平衡即可，红黑树的规则有一部分也是为了实现其整体的平衡性**



### 图

#### 图的定义

* 图（Graph）是由顶点的有穷非空集合和顶点之见边得集合组成，通常表示为：G(V,E)，其中，G表示一个图，V（Vertex）是图G中顶点得集合，E（Edge）是图G中边得集合。

![image-20200531001504790](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200531001504790.png)

##### 各种图定义

* 无向边（Edge）：若顶点v1到vi之间的边没有方向，用无序偶对（vi,vj）来表示，用小括号“**（）**“表示。
* 无向图（Undirected graphs）：任意两个顶点之间的边都是无向边。

* 完全无向图：任意两个顶点之间都存在边（![image-20200531101633546](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200531101633546.png)）

---



* 有向边/弧（Arc）：若从顶点vi到vj的边有方向，有序图<vi,vj>，vi称为**弧尾(Tail)**，vj称为**弧头(Head)**，用尖括号“<>”表示。
  * 有向图(Directed graphs)：任意两个顶点之间的边都是有向边。<A,D>表示弧**（不能反过来）**。

* 有向完全图：任意两个顶点之间都存在方向**互为相反**的两条弧

---

* 简单图：若不存在顶点到其自身的边，且同一条边不重复出现。

* 稀疏图：有很少条边或弧的图，反之称为稠密图。（相对而已，没具体定义）

* 权（Weight）：与图的边或弧相关的数。
* 网（Network）：带权的图假设有两个图 G = （V，{E}）和G‘（V'，{E’}），如果![image-20200531105958911](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200531105958911.png)，则称G’为G的子图（Subgraph）。

##### 图的顶点与边间的关系

* 对于无向图G = （V，{E}），如果边（v，v‘）∈E，即两点v,v‘互为**邻接点（Adjacent）**。边（v，v’）**依附（incident）**与两个顶点。顶点v的**度（Degree）**是和v相关联的边的数目，记为**TD（v）**
* 对于有向图G = （V，{E}），如果<v,v'>∈E，则称顶点v**邻接到**顶点v‘，顶点v‘**邻接自**顶点v。弧<v,v\>和顶点v,v’相关联。**以顶点v为头**的弧的数目称为v的**入度（InDegree）**，记为**ID（v）**；**以v为尾**的弧的数目称为**v的出度（OutDegree）**记为**OD（v）** 。顶点v的度为：TD（v）=ID(V)+OD（v）

* 从顶点v到v‘的**路径（Path）**是一个顶点序列

* 路径的长度是路径上的边或弧的数目
* 回路/环（Cycle）：第一个顶点到最后一个顶点**相同**的**路径**

* 简单路径：不重复出现的路径称为简单路径
* 简单回路/简单环：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路。

##### 连通图相关术语

* 连通图（Connected Graph）：在无向图G中，如果从顶点V到顶点V’有路径，则称v和v‘是连通的，途中任意两个顶点vi、vj∈E，vi和vj都是联通的，则为连通图。

* 无向图中的极大连通子图称为连通分量

> 1. 要是子图
> 2. 子图要是连通的
> 3. 连通子图含有极大顶点数
> 4. 具有极大的顶点数的连通子图**包含**依附于这些顶点的**所有边**

* 强连通图：向图G中，如果对于每一对vi，vj∈V、vi！=vj，从vi到vj和从vj到

vi都存在路径，则称G是强连通图。

* 有向图中的极大强连通子图称做有向的强连通图
* 连通图的生成树：一个极小的**连通子图**，它含有图中全部的**n个顶点**，但只要足以构成一棵树的**n-1条边**。

* 有向树：一个有向图恰有一个顶点入度为0，其余顶点的入度均为1

* 一个有向图的生成森林由**若干**棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧

  ![image-20200531145259641](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200531145259641.png)

#### 图的抽象数据类型

![image-20200531155417773](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200531155417773.png)

#### 图的存储结构

##### 邻接矩阵

* 邻接矩阵（Adjacency Matrix）：用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（邻接矩阵）存储图中的边或弧的信息。

![image-20200531184532550](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200531184532550.png)

* 无向边满足对称矩阵，所谓对称矩阵就是n阶矩阵的元满足aij = aji，（0<=i,j<=n）。

* 若G是网图，有n个顶点，则邻接矩阵是一个n×n的方阵：

  ![image-20200531211148901](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200531211148901.png)

* 邻接矩阵存储的结构

![image-20200531212838001](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200531212838001.png)

构造过程

![image-20200531213012921](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200531213012921.png)

![image-20200531213023886](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200531213023886.png)

* n顶点、e边，时间复杂度为O（n+n^2+e）

##### 邻接表

* 数组与链表相结合的存储方法称为邻接表（Adjacency List）
* 逆邻接表（有向图）：对每个顶点vi都建立一个链接为vi为弧头的表

![image-20200601114037281](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601114037281.png)

* 若需要权值，则再定义一个weight的数据域
* 结点定义：

![image-20200601114327998](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601114327998.png)

* 邻接表的创建

![image-20200601114723242](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601114723242.png)

![image-20200601114732475](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601114732475.png)

##### 十字链表（有向图）

* 顶点表结点结构：

![image-20200601134452380](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601134452380.png)

> firstin表示入边表头指针，指向该顶点的入边表中第一个结点，firstout表设计出边表头指针，指向改顶点的出边表中的第一个结点。

* 边表结点结构：

![image-20200601134513280](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601134513280.png)

> tailvex是指弧起点再顶点表的下标，headvex是指弧终点在顶点表中的下标，headlink是指入边表指针域，指向终点相同的下一条边。taillink是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个weight域来存储权值。

##### 邻接多重表（注重无向图的边操作）

* 顶点表结点：同邻接链表
* 边表结点：（同一条在邻接表中用两个结点表示，而在邻接多重表中只有一个结点）
* ![image-20200601144512286](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601144512286.png)

![image-20200601145346204](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601145346204.png)

##### 边集数组

* 边集数组：两个一维数组构成。一个是存储顶点的信息，另一个是存储边的信息，这个边数每个数据元素由一条边的起点下标（begin）、终点下标（end）、和权（weight）组成。

![image-20200601150919458](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601150919458.png)

#### 图的遍历

##### 深度优先遍历（DFS）

* 深度优先遍历（Depth_First_Search）：它从图中（连通）某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v由路径相通的顶点都被访问到。
* 邻接矩阵遍历：

![image-20200601155524608](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601155524608.png)

* 邻接表遍历：

![image-20200601160654126](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601160654126.png)

* 时间复杂度（n个顶点e条边）

>  邻接矩阵：O（n^2）
>
> 邻接表：O（n+e）

##### 广度优先遍历（BFS）

* 广度优先遍历（Breadth_First_Search）：类似于树的层序遍历
* 邻接矩阵：

![image-20200601165118221](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601165118221.png)

* 邻接表

![image-20200601165208400](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601165208400.png)

#### 最小生成树

* 最小生成树（Minimum Cost Spanning Tree）：构造**连通网**的最小代价生成树

##### 普里姆（Prim）算法

* 假设N = （P，{E}）是连通网，TE是N上最小生成树中边的集合。算法从U={u0}（u0∈V），TE = {}开始。重复执行下述操作：在所有u属于U，v∈V-U的边（u，v）∈E中找一条代价最小的边（u0，v0）并入集合TE，同时v0并入U，直至U=V为止。此时TE中必有n-1条边，则T = （V,{TE}）为N的最小生成树。

* 65535代表∞，以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树。
* 打印最小生成树（时间复杂度为O（n^2））：

![image-20200601174354164](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601174354164.png)

![image-20200601174401037](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601174401037.png)

![image-20200601180926451](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601180926451.png)

![image-20200601180940833](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601180940833.png)

![image-20200601180947239](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601180947239.png)

##### 克鲁斯卡尔（Kruskal）算法

* 直接找最小权值的边来构建生成树

* 假设N = (V，{E})是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T = {V，{}}，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。依此类推，直至T中所有顶点都在同一连通分量上为止。

![image-20200601212137008](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601212137008.png)

![image-20200601214041146](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601214041146.png)

![image-20200601214055484](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601214055484.png)

![image-20200601220334420](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200601220334420.png)

#### 最短路径

##### 迪杰斯特拉（Dijkstra）算法

* 基于已经求出的最短路径的基础上，求得更远顶点的最短路径（时间复杂度O（n））
* 若需知道任一顶点到其余顶点的最短路劲，则变成了O（n^3）
* **最重要的便是要找出此时离v0最近的顶点**，意味着，无论其他顶点有关的路劲如何行走，v0到这个顶点的距离必然小于从v0出发的其他未确定顶点的路径长度，以该顶点更新的到其他顶点的距离和有可能比之前的更小。（当前最小+小（可能<）之前的大于当前最小的值 ）

![image-20200603163442543](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603163442543.png)

![image-20200602000718199](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200602000718199.png)

![image-20200602000749961](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200602000749961.png)

![image-20200602135819731](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200602135819731.png)

![image-20200602135825827](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200602135825827.png)

![image-20200602141131188](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200602141131188.png)



java实现：

```java
public class DijstraAlgorithm{
    int MaxValue =10000; 
    public staitc void main(String args[]){
		Scanner in = new Scanner(System.in);
        System.out.println("请输入顶点数和边数");
        
        int vertex = input.nextInt();
        int edge = input.nextInt();
        
        int[][] matrix = new int[vertex][vertex];
        
        for(int i = 0; i < vertex; i++){
            for(int j = 0; j < vertex; j++){
                matrix[i][j] = MaxValue;
            }
        }
        
        for(int i = 0; i < edge; i++){
            System.out.println("请输入第" + (i + 1) + "条边与其权值:");
            int source = input.nextInt();
            int target = input.nextInt();
            int weight = input.nextInt();
            matrix[source][target] = weight;
        }
        
        int source = input.next;
        
        dijstra(matrix,source);
    }
    
    public void dijstra(int[][] matrix, int source){
        int[] shortest = new int[matrix.length];
        int[] visited = new int[matrix.length];
        int[] path = new int[matrix.length];
        
        for(int i = 0; i < matrix.length(); i++){
            path[i] = 0;
            shortest[i] = matrix[source][i]; 
            visited[i] = 0;
        }
        
        visited[source] = 1;
        shortest[source] = 0;
        
        for(int i = 0; i < matrix.length(); i++){
            int min = Interger.MAX_VALUE;
            int k = source;
            for(int j = 0; j < maxtrix.length(); j++){
                if(visited[j] != 0 && shortest[j] < min){
                    min = shortest[j];
                    k = j;
                }
            }
            
            visited[k] = 1;
            
            for(int j = 0; j < maxtrix.length(); j++){
                if(visited[j] != 0 && min + matrix[k][j] < shortest[j]){
                    shortest[j] = min + matrix[k][j];
                    path[j] = k;
                }
            }
        }
        
        
    }
}	   
	
```



##### Bellman-Ford

* 适用于边较少时的情况

* leecodeK战中转内最便宜的航班

  > 有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。

  > 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。

  > ```java
  > class Solution {
  >  public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
  >      int[][] dist = new int[2][n];
  >      int INF = Integer.MAX_VALUE / 2;
  >      Arrays.fill(dist[0], INF);
  >      Arrays.fill(dist[1], INF);
  >      // 初始化，使得dist的所有航班可以从src出发
  >      dist[0][src] = dist[1][src] = 0;
  > 
  >      // 0表示一次/0次中转
  >      for (int i = 0; i <= K; ++i)
  >          for (int[] edge: flights)
  >              // 采用对边的最短路径的规划，只能保证在i次中转的情况下每次都轮询所有的边（因为增加边数会改变值），求出当前到目的地的最短路径，Dijkstra则是每次求出距离最短的点并标记以是最短并轮询以他为起点的边即可
  >              // &使得两个两个数组可以轮询使用，若是固定一个需要遍历一次后更新新数组到旧数组
  >              // dist数组保存中转k及以下次数中最便宜的价格
  >              dist[i&1][edge[1]] = Math.min(dist[i&1][edge[1]], dist[~i&1][edge[0]] + edge[2]);
  > 
  >      return dist[K&1][dst] < INF ? dist[K&1][dst] : -1;
  >  }
  > }
  > ```

> dijkstra算法优化
>
> 使用hashMap减少数组查询时间
>
> 使用PriorityQueue保存最近点的消息，减少轮询全部节点的时间
>
> ```java
> class Solution {
>     public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
>         int[][] graph = new int[n][n];
>         for (int[] flight: flights)
>             graph[flight[0]][flight[1]] = flight[2];
> 
>         Map<Integer, Integer> best = new HashMap();
> 
>         // lamda表达式实现comparator接口的compare方法，依据cost排序优先队列
>         PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);
>         pq.offer(new int[]{0, 0, src});
> 
>         while (!pq.isEmpty()) {
>             int[] info = pq.poll();
>             int cost = info[0], k = info[1], place = info[2];
>             if (k > K+1 || cost > best.getOrDefault(k * 1000 + place, Integer.MAX_VALUE))
>                 continue;
>             if (place == dst)
>                 return cost;
> 
>             for (int nei = 0; nei < n; ++nei) 
>                 if (graph[place][nei] > 0) {
>                 int newcost = cost + graph[place][nei];
>                 //hashmap的key用(k+1) * 1000来减少k战中转带来的冲突
>                 if (newcost < best.getOrDefault((k+1) * 1000 + nei, Integer.MAX_VALUE)) {
>                     pq.offer(new int[]{newcost, k+1, nei});
>                     best.put((k+1) * 1000 + nei, newcost);
>                 }
>             }
>      }
>    
>         return -1;
>  }
> }
>```
> 



##### 佛洛依德（Floyd）算法

* D代表顶点到顶点的**最短路径权值和**的矩阵，P代表对应顶点的**最小路径的前驱**矩阵。

![image-20200603160740822](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603160740822.png)

![image-20200603161005635](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603161005635.png)

![image-20200603161846432](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603161846432.png)

![image-20200603161953781](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603161953781.png)

![image-20200603164404047](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603164404047.png)

* 所有顶点到所有顶点的最短路径值推导：

![image-20200603164633789](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603164633789.png)

#### 拓扑排序

* AOV网（Activity On Vertex Network）在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网。

* 拓扑路径：设G = （V,E）是一个具有n 个顶点的有向图，V中的顶点序列v1，v2，···，vn，满足若从顶点v1到vj有一条路径，则在顶点序列中顶点vi必在顶点vj之前。

* 对AOV网进行拓扑排序的基本思想是：从AOV网中选择一个**入度为0**的顶点输出，然后删去此顶点，并删除以此顶点为弧，继续重复此步骤，**直到输出全部顶点或者AOV网中不存在入度为0的顶点**为止。（需顶点全被输出，则不存在环的AOV网）

* 由于需要删除顶点，因此采用邻接表，并由于经常查找入度为0的顶点，因此增加了一个入度域in

![image-20200603173027742](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603173027742.png)

![image-20200603173125563](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603173125563.png)

#### 关键路径

* AOE网（Activity On Edge Network）：在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边便是活动的网。

* 路径上各个活动所持续的时间之和称为**路径长度**，从源点到汇点具有最大的长度的路径叫**关键路径**，在关键路径上的活动叫**关键活动**
* 时间复杂度：
* ![image-20200603215756362](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603215756362.png)

![image-20200603191633290](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603191633290.png)

* 改进过的求拓扑序列算法
* ![image-20200603214306473](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603214306473.png)

![image-20200603202832789](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603202832789.png)

![image-20200603202911963](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603202911963.png)

![image-20200603202935481](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603202935481.png)

* 求关键路径的算法（**只对只有单条关键路径**）

![image-20200603204934087](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603204934087.png)

![image-20200603204942607](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603204942607.png)

![image-20200603214953151](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603214953151.png)

![image-20200603214130527](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603214130527.png)

![image-20200603214137320](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603214137320.png)

![image-20200603215655771](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200603215655771.png)

### 查找

#### 查找概论

* 查找（Searching） 就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。

* 查找表（Search Table）：是由同一类型的数据元素（或记录）构成的集合。

* 关键字/键值（Key）：是数据元素中某个数据项的值。

* 主关键字（Primary Key）：可以唯一的标识一个记录

  > 次关键字（Secondary Key）：可以识别多个数据元素（或记录） 的关键字。

* 查找表：**静态查找表和动态查找表**

* 静态查找表（Static Search Table）：只作查找操作的查找表

> （1）查询某个“特定的”数据元素是否在查找表中
>
> （2）检索某个“特定的”数据元素和各种属性

* 动态查找表（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个元素

> （1）查找时插入数据元素
>
> （2）查找时删除数据元素

#### 顺序表查找

* 顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是：从表中的第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。

* 顺序表查找算法：

![image-20200604133647473](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200604133647473.png)

* 优化（a[0]设置为哨兵）

![image-20200604133700487](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200604133700487.png)

#### 有序表查找

##### 折半查找

* 折半查找（Binary Search）技术/二分查找。

  > 前提：线性表钟的记录必须是关键码有序，采用顺序存储。
  >
  > 基本思想：在有序表钟，取中间记录作为比较对象，若相等则成功，反之则分别往相应半区继续查找。
  >
  > 时间复杂度：O（logn）

![image-20200606143035890](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606143035890.png)

##### 插值查找

* 插值查找（Interpolation Search）

  > 根据要查找的关键字key与查找表中最大最小记录的关键字比较厚的查找方法.
  >
  > 时间复杂度也为O（logn），但对于**关键字分布比较均匀的查找表**，性能比折半查询好。
  >
  > 关键在于将1/2换为（key-a[low])/(a[high]-a[low])

##### 斐波那契查找

* 斐波那契查找（Fibonacci Search）

![image-20200606150807590](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606150807590.png)

![image-20200606150816168](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606150816168.png)

![image-20200606165251820](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606165251820.png)

![image-20200606165258812](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606165258812.png)

* F[K] = F[K-1]+F[K-2]为基础，时间复杂度也为O[logn]，但只有在要查找的记录在右侧时，效率较高

#### 线性索引查找

* 索引就是把一个关键字与它相应的记录相关联的过程。
* 所谓线性索引就是将**索引项集合**组织为线性结构，也称为索引表

##### 稠密索引

* 数据集中的每个记录对应一个索引项
* 索引项一定是按照关键码有序的排列

##### 分块索引

* 分块有序，是把数据集的记录分成若干块：

> 1. 块内无序（有序代价较大）
> 2. 块间有序

* 对于分块有序的数据集，将每块对应一个索引项，即为分块索引：

>  最大关键码
>
> 存储了块中的个数（循环用）
>
> 用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历

![image-20200606180011384](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606180011384.png)

* n个记录被分为m块，每个块中有t条记录。索引表的平均查找长度Lb：（m+1）/2，块中平均查找长度（t+1）/2

  > 分块索引查找的平均查找长度为：ASLw = Lb+Lw =  1/2(m+t)+1 = 1/2(n/t+t) +1
  >
  > 求导可得，n = t时，ASLw最小，为![image-20200606190426350](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606190426350.png)

##### 倒排索引（升级版方向是搜索引擎）

* 倒排索引（inverted index）：记录号表存储具有**相同次关键字**的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）

#### 二叉排序树

* 二叉排序树（Binary Sort Tree）/二叉查找树：

> 要么是空树，或者需要具备下列性质：
>
> * 若他的左子树不空，则左子树上所有结点的值均小于它的根结构的值；
> * 若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值；
> * 它的左、右子树也分别为二叉排序树

##### 查找

> ![image-20200606204200442](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606204200442.png)
>
> ![image-20200606204213316](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606204213316.png)
>
> ![image-20200606204222771](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606204222771.png)

##### 插入

![image-20200606204623474](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606204623474.png)

![image-20200606204632589](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606204632589.png)

##### 删除

* 删除结点的三种情况：

  > 1. 叶子节点
  > 2. 仅有左或右子树的结点
  > 3. 左右子树都有的结点

![image-20200606213102597](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606213102597.png)

![image-20200606213118790](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606213118790.png)

![image-20200606221033744](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606221033744.png)

* 二叉查找树的查找效率与二叉树的树型有关, 若与完全二叉树相同则为O（logn），若为斜树则为O（n）其查找效率最低。
* ![image-20200606221409483](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200606221409483.png)

#### 平衡二叉树（AVL树）

* 平衡二叉树（Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。
* 平衡因子BF（Balance Factor）：结点**左子树深度减去右子树深度**的值。
* 时间复杂度：查找O（logn），插入和删除O（logn）

##### 结点结构

![image-20200607184916303](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200607184916303.png)

##### 右旋

![image-20200607184932584](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200607184932584.png)

![image-20200607185605965](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200607185605965.png)

##### 左旋

![image-20200607185720875](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200607185720875.png)

##### 左平衡旋转

![image-20200607190110174](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200607190110174.png)

![image-20200607190117686](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200607190117686.png)

##### 主函数

![image-20200608101028364](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200608101028364.png)

![image-20200608101259991](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200608101259991.png)

![image-20200608101310450](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200608101310450.png)

#### 多路查找树（B树）

* 2-3树是这样一棵多路查找树：其中的每一个结点都具有两个孩子（2结点）或三个孩子（3结点）
* 一个2结点包含一个元素和两个孩子（或没有孩子），不能只有一个孩子
* 一个3结点包含一小一大两个元素和三个孩子（或没有孩子）

* 所有叶子都在一个层次上

##### 2-3树的插入实现

1. 对于空树，插入一个2结点即可
2. 插入结点到一个2结点的叶子上
3. 要往3结点钟插入一个新元素

![image-20200608194505571](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200608194505571.png)

![image-20200608194513539](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200608194513539.png)

##### 2-3树的删除实现

1. 所删除的结点位于一个3结点的叶子结点上

2. 所删除的元素位于一个2结点上

   > 四种情形：
   >
   > ![image-20200608194926680](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200608194926680.png)
   >
   > ![image-20200608194938297](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200608194938297.png)
   >
   > ![image-20200608194950774](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200608194950774.png)

3. 删除的元素位于非叶子的分支结点（按中序遍历后得到的前驱或后继补位）

![image-20200608195502274](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200608195502274.png)

##### B树

* B树（B-tree）是一种平衡的多路查找树，节点最大的孩子数目称为B树的阶（order）

  > ![image-20200608195646328](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200608195646328.png)

* 最坏查找情况:

> ![image-20200608195713745](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200608195713745.png)

##### B+树

* 为了解决遍历问题，遍历时不需要一直返回上一个结点

> ![image-20200608200014269](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200608200014269.png)

#### 散列表查找（哈希表）

* 主要面向查找的存储结构，记录间不存在什么逻辑关系
* 散列技术最适合的求解问题事查找与**给定值相等**的记录
* 冲突：两个关键字key1 != key2，但是f（key1）=f（key2）,并把key1和key2称为这个散列函数的同义词（synonym）

* 存储位置 = f（关键字）

  > * 散列技术：在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）
  > * 关系f：称为散列函数f/哈希函数（Hash）
  > * 哈希表（Hash table）:采用散列技术将记录存储在一块连续的存储空间中

##### 散列表查找步骤

1. 在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。             

2. 当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。

#### 散列函数的构造方法

* 原则：

> 1. 计算简单
> 2. 散列地址分布均匀

##### 直接定址法

![image-20200609170831462](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609170831462.png)

> 需事先知道关键的分布情况，适合寻找表较小且连续的情况

##### 数字分析法

* 抽取：使用关键字的一部分来计算散列存储位置的方法。（事先知道关键字的若干位分布较均匀）

##### 平方取中法

![image-20200609172651637](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609172651637.png)

##### 折叠法

![image-20200609172900870](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609172900870.png)

##### 除留余数法

![image-20200609173345038](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609173345038.png)

##### 随机数法

![image-20200609173450224](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609173450224.png)

#### 处理冲突

##### 开放地址法

* 开放定地址法（线性探测法）：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入

![image-20200609174543516](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609174543516.png)

* 堆积：不是同义词却因为di而争夺一个地址的情况

* 为了不让关键字都聚集在某一块区域，增加了平方运算，称之为二次探测法

  ![image-20200609180655581](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609180655581.png)

* 或者将di用随机函数（伪随机数）计算得到，称为随机探测法（相同的随机种子，将得到相同的数列）

##### 再散列函数法

![image-20200609200259922](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609200259922.png)

* RH1是不同的散列函数

##### 链地址法

* 将所有关键字为同义词的记录存储在一个单链表中

![image-20200609200651811](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609200651811.png)

##### 公共溢出区法

* 所有冲突的关键字建立了一个公共的溢出区来存放

![image-20200609201117657](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609201117657.png)

#### 查找实现

* 散列表结构：

![image-20200609204636861](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609204636861.png)

![image-20200609204645028](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609204645028.png)

* 散列表初始化：

![image-20200609204715269](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609204715269.png)

* 散列函数：

![image-20200609204743118](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609204743118.png)

* 插入操作：

![image-20200609204934838](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609204934838.png)

![image-20200609204945397](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609204945397.png)

* 查找

![image-20200609205044805](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609205044805.png)

##### 性能分析

1. 散列函数是否均匀

2. 处理冲突的方法

3. 散列表的填装因子：填入表中的记录个数/散列表长度

### 排序

![image-20200611164115502](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611164115502.png)

#### 排序的基本分类和概念

![image-20200609212822639](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609212822639.png)

* 多个关键字的可以转换为一个关键字

##### 排序的稳定性

* 假设ki = kj（1<=i<=n,1<=j<=n,i!=j），且在**排序前**的序列中r1领先于rj（即i<j），如果**排序后**r1仍领先于rj，则为稳定的，反之，排序后rj领先于ri，则为不稳定的。

##### 内排序与外排序

* 内排序：排序整个过程中，待排序的所有记录全部被放置在内存中
* 外排序：排序的记录个数太多，不能同时放置在内存，需在内外存之间多次交换数据才行

* 内排序性能影响：

  > 1. 时间性能：比较和移动
  > 2. 辅助空间：除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间
  > 3. 算法的复杂性：插入排序、交换排序、选择排序和归并排序

##### 排序用到的结构与函数

![image-20200609220517123](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609220517123.png)

![image-20200609220524330](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609220524330.png)

#### 冒泡排序

* 冒泡排序（Bubble Sort）：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。

* 简单的效率低下的排序：（对其余关键字的排序没有什么帮助，最好最坏的时间效率和冒泡一致）

![image-20200609231834401](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609231834401.png)

* 冒泡排序：（即将对应的关键字提了上来，还将其他的也提了上来）

![image-20200609231940861](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609231940861.png)

![image-20200609231955215](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609231955215.png)

* 冒泡排序优化

![image-20200609232232822](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609232232822.png)

* 复杂度：最好n-1次比较，0次数据交换，最坏n（n-1）/2次比较和数据交换，时间复杂度为O（n^2）

#### 简单选择排序

* 简单排序算法（Simple Selection Sort）：通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i（1<=i<=n）个记录交换之。

![image-20200609234148140](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609234148140.png)

* 复杂度：

> 比较：无论好坏：n（n-1）/2
>
> 交换：最好：0，最坏n-1
>
> 总的：O（n^2），但因为移动次数仍略优于冒泡（未优化）

#### 直接插入排序

* 直接插入排序（Straight Insertion Sort）：将一个记录插入到已经排好序，从而得到一个新的、记录数增1的有序表。
* 复杂度：

> 最好的情况：比较次数n-1 ，没有移动记录 O(n)
>
> 最坏的情况：比较![image-20200610145140370](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200610145140370.png)
>
> ​				 	移动：![image-20200610145212839](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200610145212839.png)
>
> 平均比较和移动次数约为：(n^2)/4 时间复杂度：O（n^2）

![image-20200609235257942](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609235257942.png)

![image-20200609235308501](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200609235308501.png)

eg：

![image-20200610141920046](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200610141920046.png)

![image-20200610141928833](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200610141928833.png)

#### 希尔排序

* 为了使整个序列基本有序发展，采用**跳跃分割**的策略：

  > 将相距某个**“增量”**的记录组成一个子序列，这样才能保证子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。

* 希尔排序算法：

![image-20200610161201231](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200610161201231.png)

* 若长度为9，则增量increment由4变为2变为1，增量序列的**最后一个增量值必须等于1**.
* 当增量序列为dlta[k]=2^(t-k+1)-1时，
* ![image-20200610193045172](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200610193045172.png)，时间复杂度为O（n^(3/2)）

#### 堆排序

* 堆：具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；每个结点的值都小于或等于其左右孩子的值，称为小顶堆。

* 结点之间满足如下关系：

  ![image-20200610205755161](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200610205755161.png)

* 堆排序（Heap Sort）：

  * 若是逐个插入构造大顶堆，可以从下往上向上调整，每次只需比较更改的点和他的父节点的值即可
  * 若是将以存在的乱序堆

    1. 将待排序的序列构造成一个大顶堆。此时：整个序列的最大值就是堆顶的根节点（整个堆排序整体上，从下往上、从右往左。同时每个非终端结点（非叶节点）当作根节点，从上往下，将其和其子树调整成大顶堆）（或者整体从上往下，每个非叶子节点从下往上）（为什么这样，可以保证每次只有左子树或右子树节点值变换，只需遍历一边，且该节点的序列排序后是大顶堆	）

    2. 将堆顶记录和当前未经排序子序列的最后一个记录交换，再将数组的【1，i-1】调整为大顶堆（为什么专门交换将堆顶与叶子节点交换？因为这样便变成了构造成大顶堆的最后根节点的比较，只需构造大顶堆的最后一步的堆顶记录的重排序即可，而不是左子树或右子树的移位然后再全部进行一次第一步的构造过程）																			

* 堆复杂度：

> 对于每个非终端结点来说，最多会有2（h（高度）-x(第x层)）的比较和交换操作（除开叶子节点），时间复杂度若是完全二叉树为：s = 1*2^(h-1) + 2*2^(h-2)+……+h*2^0 ，求和得s = 2n - 2 - log2(n)，近似的时间复杂度就是O(n)，因此整个构建堆的时间复杂度为O（n），
>
> 正式排序时，第i次取堆顶记录重建堆需要用O（logi）的时间（完全二叉树的某个结点到根节点的**距离**为![image-20200611124046913](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611124046913.png),因此，**堆的排序**的总时间复杂度为**O（nlogn）**）
>
> 堆排序对原始记录的排序状态并不敏感，即好、坏、平均都为O（nlogn）,但因跳跃而是**不稳定的**

​													![image-20200610235549785](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200610235549785.png)	

​													![image-20200610235035442](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200610235035442.png)		   

#### 归并排序

##### 递归的归并排序

* 归并排序（Merging Sort）：假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到![image-20200611130010711](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611130010711.png)个长度为2或1的有序子序列，再两两归并，直至得到一个长度为n的有序序列，称为2路归并排序。

* 复杂度：

  > 时间复杂度：
  >
  > 将待排有序序列所有记录扫描一遍，耗费O（n）时间，整个归并排序，需要进行![image-20200611155322328](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611155322328.png)
  >
  > 空间复杂度：
  >
  > ![image-20200611155419303](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611155419303.png)

* 主函数

![image-20200611132838517](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611132838517.png)

* MSORT

![image-20200611132845101](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611132845101.png)

* Merge

![image-20200611134302367](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611134302367.png)

![image-20200611134309263](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611134309263.png)

##### 非递归的归并排序

* 主函数

![image-20200611160053479](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611160053479.png)

* 归并函数

![image-20200611160045226](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611160045226.png)

* n-2*s+1是为了能两两归并

* 避免了递归时深度为log2n的栈空间，空间复杂度为O（n），也因此提高了时间性能。

#### 快速排序

* 快速排序（Quick Sort） ：通过将一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序的目的。

![image-20200611164841155](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611164841155.png)

![image-20200611164848137](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611164848137.png)

![image-20200611175452921](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611175452921.png)

![image-20200611175459472](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611175459472.png)

![image-20200611202115777](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611202115777.png)

![image-20200611202140961](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611202140961.png)

##### 优化

1. 优化选取枢轴

* 三数取中法（左中右）

* 随机数

2. 优化不必要的交换

![image-20200611204655337](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611204655337.png)

![image-20200611204702262](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611204702262.png)

3. 优先小数组时的排序方案

![image-20200611205029924](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611205029924.png)

4. 优化递归操作

![image-20200611210054125](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611210054125.png)

#### 总结

![image-20200611212802285](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611212802285.png)

* 两类算法：

> 简单算法：冒泡、简单选择、直接插入
>
> 改进算法：希尔、堆、归并、快速

* 三种情况：

> ![image-20200611213313363](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611213313363.png)

* 空间复杂度、稳定性、待排序个数

![image-20200611213657358](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611213657358.png)

![image-20200611213706357](F:\Typora数据储存\基础课程\大话数据结构.assets\image-20200611213706357.png)

* 综合来说，经过优化的快排是性能最好的排序算法